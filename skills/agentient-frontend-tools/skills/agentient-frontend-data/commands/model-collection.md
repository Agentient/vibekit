---
name: model-collection
description: Generate a type-safe Firestore collection with Zod schema, TypeScript types, and withConverter objects for runtime validation
---

# /model-collection Command

**Purpose**: Create a complete, type-safe Firestore collection definition with Zod schema, inferred TypeScript types, and client/server converters.

## Usage

```bash
/model-collection
```

The command will interactively prompt you for collection details or you can provide them upfront:

```bash
/model-collection --collection posts --fields "title:string,content:string,authorId:string,status:enum(draft|published|archived)"
```

## What This Command Generates

1. **Zod Schema**: Runtime validation definition
2. **TypeScript Type**: Inferred from Zod schema
3. **Client Converter**: `zodConverter` with validation on read/write
4. **Server Converter**: `zodAdminConverter` for server-side operations
5. **Baseline Security Rules**: User-scoped access rules
6. **Index Configuration** (if complex queries identified)

## Output Structure

```
src/lib/firebase/
├── schemas/
│   └── [collection].schema.ts    # Zod schema + converters
├── security/
│   └── [collection].rules         # Baseline security rules
└── indexes/
    └── [collection].indexes.json  # Composite indexes (if needed)
```

## Interactive Prompts

The command will ask:

1. **Collection Name**: Singular, lowercase (e.g., `post`, `user`, `comment`)
2. **Fields**: Name, type, validation rules
   - Supported types: string, number, boolean, timestamp, reference, enum, array
   - Validation: min/max length, required/optional, custom constraints
3. **Relationships**: Parent collection, reference fields
4. **Access Patterns**: Who can read/write? (for security rules)
5. **Query Patterns**: Filters and sorting (for index generation)

## Example Session

```
User: /model-collection

Agent: I'll help you create a type-safe Firestore collection.

Collection name (singular): post

Fields (one per line, format: name:type:validation):
  title:string:min(1),max(200),required
  content:string:required
  authorId:string:required
  status:enum:draft,published,archived
  viewCount:number:default(0)
  createdAt:timestamp:required
  updatedAt:timestamp:required

Relationships:
  - Author reference? (y/n): y
  - Parent collection: user
  - Reference field: authorId

Access Patterns:
  - Who can create posts? authenticated users
  - Who can read posts? anyone (if published), author (if draft)
  - Who can update posts? author only
  - Who can delete posts? author only

Query Patterns:
  1. List published posts, sorted by createdAt DESC
  2. List user's own posts (any status), sorted by updatedAt DESC

Generating files...
✓ src/lib/firebase/schemas/post.schema.ts
✓ src/lib/firebase/security/post.rules
✓ src/lib/firebase/indexes/post.indexes.json

Next steps:
1. Review generated files
2. Deploy security rules: firebase deploy --only firestore:rules
3. Deploy indexes: firebase deploy --only firestore:indexes
```

## Generated Schema Example

```typescript
// src/lib/firebase/schemas/post.schema.ts
import { z } from 'zod';
import { Timestamp } from 'firebase/firestore';
import { zodConverter, zodAdminConverter } from '../zodConverter';

/**
 * Post Schema
 * Represents a blog post with title, content, and publication status
 */
export const PostSchema = z.object({
  id: z.string(),
  title: z.string().min(1, 'Title required').max(200, 'Title too long'),
  content: z.string().min(1, 'Content required'),
  authorId: z.string(),
  status: z.enum(['draft', 'published', 'archived']),
  viewCount: z.number().int().nonnegative().default(0),
  createdAt: z.instanceof(Timestamp),
  updatedAt: z.instanceof(Timestamp),
});

/**
 * Post TypeScript Type
 * Inferred from Zod schema to ensure type-schema alignment
 */
export type Post = z.infer<typeof PostSchema>;

/**
 * Client-side converter with validation on read and write
 */
export const postConverter = zodConverter(PostSchema);

/**
 * Server-side converter (Admin SDK) with validation on read
 */
export const postAdminConverter = zodAdminConverter(PostSchema);

/**
 * Example usage in a Server Component:
 *
 * import { adminDb } from '@/lib/firebase/admin';
 * import { postAdminConverter } from '@/lib/firebase/schemas/post.schema';
 *
 * const postsRef = adminDb.collection('posts').withConverter(postAdminConverter);
 * const snapshot = await postsRef.where('status', '==', 'published').get();
 * const posts = snapshot.docs.map(doc => doc.data()); // Type: Post[]
 */
```

## Generated Security Rules Example

```
// src/lib/firebase/security/post.rules
rules_version = '2';

// GENERATED BY: /model-collection command
// Collection: posts
// Generated: 2025-10-23

service cloud.firestore {
  match /databases/{database}/documents {
    match /posts/{postId} {
      // Anyone can read published posts
      // Authors can read their own posts (any status)
      allow read: if resource.data.status == 'published'
                  || request.auth.uid == resource.data.authorId;

      // Authenticated users can create posts
      // Must set authorId to their own UID
      allow create: if request.auth != null
                    && request.resource.data.authorId == request.auth.uid
                    && request.resource.data.keys().hasAll(['title', 'content', 'authorId', 'status']);

      // Authors can update their own posts
      // Cannot change authorId
      allow update: if request.auth.uid == resource.data.authorId
                    && request.resource.data.authorId == resource.data.authorId;

      // Authors can delete their own posts
      allow delete: if request.auth.uid == resource.data.authorId;
    }
  }
}
```

## Generated Index Example

```json
{
  "indexes": [
    {
      "collectionGroup": "posts",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "status", "order": "ASCENDING" },
        { "fieldPath": "createdAt", "order": "DESCENDING" }
      ]
    },
    {
      "collectionGroup": "posts",
      "queryScope": "COLLECTION",
      "fields": [
        { "fieldPath": "authorId", "order": "ASCENDING" },
        { "fieldPath": "updatedAt", "order": "DESCENDING" }
      ]
    }
  ],
  "fieldOverrides": []
}
```

## Integration with Other Commands

- **Follow up with `/generate-security-rules`** to add RBAC or multi-tenant rules
- **Use `/create-auth-flow`** if collection requires user authentication
- **Reference in `/setup-firebase`** to ensure SDK initialization includes this collection

## Best Practices

✅ **Do**:
- Use singular collection names (`user`, not `users`)
- Mark new fields as optional when evolving schemas
- Generate indexes for all multi-field queries
- Include timestamps for audit trails

❌ **Don't**:
- Embed large arrays (use subcollections instead)
- Skip security rules generation
- Use `any` type in converters
- Hardcode enum values outside Zod schema

## Troubleshooting

**Issue**: "Zod validation error on existing documents"
**Solution**: Mark new fields as `.optional()` or provide `.default()` values

**Issue**: "Index required error in development"
**Solution**: Click the Firestore Console link in the error message to auto-generate, or deploy the generated indexes

**Issue**: "Security rule denies write"
**Solution**: Review access patterns in generated rules and adjust for your use case

---

**Related Commands**: `/setup-firebase`, `/generate-security-rules`, `/create-auth-flow`
**Skill Dependencies**: `firestore-data-modeling-patterns`, `zod-firestore-type-safety`
