---
name: generate-security-rules
description: Generate granular Firestore and Storage security rules with user-scoped access, RBAC, and multi-tenant patterns
---

# /generate-security-rules Command

**Purpose**: Automatically generate production-ready Firebase security rules based on data models, access patterns, and business requirements. Supports user-scoped access, role-based access control (RBAC), and multi-tenant architectures.

## Usage

```bash
/generate-security-rules
```

Or specify collections and patterns upfront:

```bash
/generate-security-rules --collections posts,comments --pattern rbac --roles admin,moderator,user
```

## What This Command Generates

1. **Firestore Security Rules** (`firestore.rules`)
2. **Storage Security Rules** (`storage.rules`) - if Cloud Storage is configured
3. **Test Suite** (`firestore.rules.spec.ts`) - for validating rules locally
4. **Documentation** (`SECURITY_RULES.md`) - explaining access patterns

## Output Structure

```
firebase/
├── firestore.rules              # Firestore security rules
├── storage.rules                # Storage security rules
└── tests/
    └── firestore.rules.spec.ts  # Rules test suite

docs/
└── SECURITY_RULES.md            # Security documentation
```

## Interactive Prompts

The command will ask:

1. **Collections to Secure**: Select from existing collections or specify new ones
2. **Access Patterns** for each collection:
   - Public read, authenticated write
   - User-scoped (users can only access their own data)
   - Role-based (access controlled by custom claims)
   - Multi-tenant (data isolated by tenantId)
3. **Field Validation Rules**: Required fields, data types, value constraints
4. **Cascade Delete Rules**: Prevent orphaned data
5. **Rate Limiting**: Prevent abuse (e.g., max 10 writes per user per minute)

## Example Session

```
User: /generate-security-rules

Agent: I'll help you generate security rules for your Firestore collections.

Existing collections detected:
  1. users
  2. posts
  3. comments

Select collections to secure (comma-separated): posts,comments

=== Collection: posts ===

Access Pattern:
  1. Public read, authenticated write
  2. User-scoped (author only)
  3. Role-based (admin, moderator, user)
  4. Multi-tenant

  Choice: 2 (User-scoped)

Who can READ posts?
  1. Anyone (public)
  2. Author only
  3. Author + published posts are public

  Choice: 3

Who can CREATE posts?
  1. Any authenticated user
  2. Verified email users only
  3. Users with specific role

  Choice: 1

Who can UPDATE posts?
  1. Author only
  2. Author + admins
  3. Author + admins + moderators

  Choice: 2

Who can DELETE posts?
  1. Author only
  2. Admins only
  3. Author + admins

  Choice: 3

Field Validations:
  Required fields: title, content, authorId, status, createdAt
  Immutable fields: authorId, createdAt
  Enum constraints: status in ['draft', 'published', 'archived']

=== Collection: comments ===

Access Pattern: 1 (Public read, authenticated write)

Cascade Delete Protection:
  Prevent deletion of posts with comments? y

Generating files...
✓ firestore.rules (with user-scoped + RBAC patterns)
✓ firebase/tests/firestore.rules.spec.ts
✓ docs/SECURITY_RULES.md

Next steps:
1. Review generated rules in firestore.rules
2. Run tests: npm run test:rules
3. Deploy: firebase deploy --only firestore:rules
```

## Generated Firestore Security Rules

```
// firestore.rules
rules_version = '2';

// GENERATED BY: /generate-security-rules command
// Generated: 2025-10-23
// Collections: posts, comments
// Patterns: User-scoped + RBAC

service cloud.firestore {
  match /databases/{database}/documents {

    // ========================================================================
    // HELPER FUNCTIONS
    // ========================================================================

    /**
     * Check if user is authenticated
     */
    function isAuthenticated() {
      return request.auth != null;
    }

    /**
     * Check if user has a specific role
     */
    function hasRole(role) {
      return isAuthenticated() && request.auth.token.role == role;
    }

    /**
     * Check if user is admin
     */
    function isAdmin() {
      return hasRole('admin');
    }

    /**
     * Check if user is the document owner
     */
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    /**
     * Validate required fields exist
     */
    function hasRequiredFields(fields) {
      return request.resource.data.keys().hasAll(fields);
    }

    /**
     * Validate field is not modified
     */
    function isImmutable(field) {
      return request.resource.data[field] == resource.data[field];
    }

    // ========================================================================
    // COLLECTION: posts
    // ========================================================================

    match /posts/{postId} {

      /**
       * READ: Anyone can read published posts, authors can read their own
       */
      allow read: if resource.data.status == 'published'
                  || isOwner(resource.data.authorId)
                  || isAdmin();

      /**
       * CREATE: Any authenticated user can create posts
       * Requirements:
       * - Must set authorId to their own UID
       * - Must include required fields
       * - Status must be valid enum value
       */
      allow create: if isAuthenticated()
                    && request.resource.data.authorId == request.auth.uid
                    && hasRequiredFields(['title', 'content', 'authorId', 'status', 'createdAt'])
                    && request.resource.data.status in ['draft', 'published', 'archived']
                    && request.resource.data.title is string
                    && request.resource.data.title.size() > 0
                    && request.resource.data.title.size() <= 200
                    && request.resource.data.content is string
                    && request.resource.data.content.size() > 0;

      /**
       * UPDATE: Authors can update their own posts, admins can update any
       * Restrictions:
       * - Cannot change authorId (immutable)
       * - Cannot change createdAt (immutable)
       */
      allow update: if (isOwner(resource.data.authorId) || isAdmin())
                    && isImmutable('authorId')
                    && isImmutable('createdAt')
                    && request.resource.data.status in ['draft', 'published', 'archived'];

      /**
       * DELETE: Authors and admins can delete posts
       */
      allow delete: if isOwner(resource.data.authorId) || isAdmin();
    }

    // ========================================================================
    // COLLECTION: comments
    // ========================================================================

    match /comments/{commentId} {

      /**
       * READ: Anyone can read comments
       */
      allow read: if true;

      /**
       * CREATE: Any authenticated user can create comments
       * Requirements:
       * - Must set authorId to their own UID
       * - Must reference a valid postId
       * - Content must be non-empty
       */
      allow create: if isAuthenticated()
                    && request.resource.data.authorId == request.auth.uid
                    && hasRequiredFields(['content', 'authorId', 'postId', 'createdAt'])
                    && request.resource.data.content is string
                    && request.resource.data.content.size() > 0
                    && request.resource.data.content.size() <= 1000
                    && exists(/databases/$(database)/documents/posts/$(request.resource.data.postId));

      /**
       * UPDATE: Authors can update their own comments
       * Restrictions:
       * - Cannot change authorId or postId (immutable)
       */
      allow update: if isOwner(resource.data.authorId)
                    && isImmutable('authorId')
                    && isImmutable('postId')
                    && isImmutable('createdAt');

      /**
       * DELETE: Authors can delete their own comments, admins can delete any
       */
      allow delete: if isOwner(resource.data.authorId) || isAdmin();
    }

    // ========================================================================
    // COLLECTION: users (User Profiles)
    // ========================================================================

    match /users/{userId} {
      /**
       * READ: Users can read their own profile, admins can read all
       */
      allow read: if isOwner(userId) || isAdmin();

      /**
       * CREATE: Only during sign-up (via Server Action)
       */
      allow create: if isOwner(userId)
                    && hasRequiredFields(['email', 'displayName', 'createdAt']);

      /**
       * UPDATE: Users can update their own profile
       * Restrictions:
       * - Cannot change role (use custom claims API)
       * - Cannot change createdAt
       */
      allow update: if isOwner(userId)
                    && isImmutable('createdAt')
                    && (!('role' in request.resource.data) || isImmutable('role'));

      /**
       * DELETE: Admins only
       */
      allow delete: if isAdmin();
    }
  }
}
```

## Multi-Tenant Security Pattern

```
// Multi-Tenant Pattern (if requested)

/**
 * Check if user belongs to the document's tenant
 */
function belongsToTenant(tenantId) {
  return isAuthenticated() && request.auth.token.tenantId == tenantId;
}

match /tenant-data/{docId} {
  allow read, write: if belongsToTenant(resource.data.tenantId);
}

match /tenants/{tenantId}/data/{docId} {
  // Alternative subcollection pattern
  allow read, write: if belongsToTenant(tenantId);
}
```

## Generated Storage Rules

```
// storage.rules
rules_version = '2';

service firebase.storage {
  match /b/{bucket}/o {

    // User profile images
    match /users/{userId}/avatar/{filename} {
      // Users can upload their own avatar
      allow read: if true; // Public read
      allow write: if request.auth != null
                   && request.auth.uid == userId
                   && request.resource.size < 5 * 1024 * 1024 // Max 5MB
                   && request.resource.contentType.matches('image/.*');
    }

    // Post images
    match /posts/{postId}/images/{filename} {
      // Anyone can read published post images
      allow read: if true;

      // Post authors can upload images
      allow write: if request.auth != null
                   && request.resource.size < 10 * 1024 * 1024 // Max 10MB
                   && request.resource.contentType.matches('image/.*');

      // Admins can delete
      allow delete: if request.auth.token.role == 'admin';
    }
  }
}
```

## Generated Test Suite

```typescript
// firebase/tests/firestore.rules.spec.ts
import { assertFails, assertSucceeds } from '@firebase/rules-unit-testing';
import { initializeTestEnvironment, RulesTestEnvironment } from '@firebase/rules-unit-testing';

let testEnv: RulesTestEnvironment;

beforeAll(async () => {
  testEnv = await initializeTestEnvironment({
    projectId: 'test-project',
    firestore: {
      rules: fs.readFileSync('firestore.rules', 'utf8'),
    },
  });
});

afterAll(async () => {
  await testEnv.cleanup();
});

describe('Posts Collection', () => {
  test('Authenticated user can create post', async () => {
    const alice = testEnv.authenticatedContext('alice');
    await assertSucceeds(
      alice.firestore().collection('posts').add({
        title: 'Test Post',
        content: 'Content',
        authorId: 'alice',
        status: 'draft',
        createdAt: new Date(),
      })
    );
  });

  test('Unauthenticated user cannot create post', async () => {
    const unauth = testEnv.unauthenticatedContext();
    await assertFails(
      unauth.firestore().collection('posts').add({
        title: 'Test Post',
        content: 'Content',
        authorId: 'anonymous',
        status: 'draft',
        createdAt: new Date(),
      })
    );
  });

  test('User cannot create post with wrong authorId', async () => {
    const alice = testEnv.authenticatedContext('alice');
    await assertFails(
      alice.firestore().collection('posts').add({
        title: 'Test Post',
        content: 'Content',
        authorId: 'bob', // Wrong!
        status: 'draft',
        createdAt: new Date(),
      })
    );
  });
});
```

## Integration with Other Commands

- **Integrates with `/model-collection`** to derive rules from schemas
- **Requires `/create-auth-flow`** for RBAC and custom claims
- **Works with `/setup-firebase`** for deployment configuration

## Best Practices

✅ **Do**:
- Default deny, explicitly allow
- Validate all user input (types, sizes, formats)
- Use helper functions for reusable logic
- Test rules locally before deploying
- Document complex rules with comments

❌ **Don't**:
- Allow unrestricted write access
- Skip field validation
- Use `allow read, write: if true` in production (except for truly public data)
- Forget to set immutable fields (createdAt, authorId)
- Deploy without testing

## Troubleshooting

**Issue**: "Permission denied" even for authenticated users
**Solution**: Check that `request.auth.uid` matches the expected field

**Issue**: "Property is undefined" error in rules
**Solution**: Use `'field' in resource.data` before accessing `resource.data.field`

**Issue**: "Rules exceed size limit"
**Solution**: Extract common patterns into helper functions

**Deploy Command**:
```bash
firebase deploy --only firestore:rules
```

**Test Command**:
```bash
npm run test:rules
```

---

**Related Commands**: `/model-collection`, `/create-auth-flow`, `/setup-firebase`
**Skill Dependencies**: `firestore-security-rules-generation`, `firebase-authentication-patterns`
